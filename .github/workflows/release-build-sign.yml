name: Release Build and Sigstore Sign

on:
  push:
    tags:
      - "v*"
  workflow_dispatch:
    inputs:
      tag:
        description: "Release tag to publish (example: v1.3.5)"
        required: true
        type: string

permissions:
  contents: write
  id-token: write

jobs:
  build-sign-release:
    runs-on: windows-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Resolve tag
        id: vars
        shell: pwsh
        run: |
          $tag = "${{ github.event.inputs.tag }}"
          if ([string]::IsNullOrWhiteSpace($tag)) {
            $tag = "${{ github.ref_name }}"
          }
          if ([string]::IsNullOrWhiteSpace($tag)) {
            throw "Unable to resolve release tag."
          }
          if (-not $tag.StartsWith("v")) {
            throw "Tag must start with 'v' (received: $tag)."
          }
          "tag=$tag" >> $env:GITHUB_OUTPUT
          "version=$($tag.Substring(1))" >> $env:GITHUB_OUTPUT

      - name: Install build requirements
        shell: pwsh
        run: |
          python -m pip install --upgrade pip
          pip install -r source/requirements-build.txt
          pip install semgrep bandit safety

      - name: Install TruffleHog
        shell: pwsh
        run: |
          try {
            $rel = Invoke-RestMethod -Uri "https://api.github.com/repos/trufflesecurity/trufflehog/releases/latest" -Headers @{ "User-Agent" = "hackhub-release-build" }
            $asset = $rel.assets | Where-Object { $_.name -match "windows_amd64\.(zip|tar\.gz)$" } | Select-Object -First 1
            if (-not $asset) {
              Write-Host "TruffleHog asset not found for windows_amd64; continuing without install."
              exit 0
            }
            $tmp = Join-Path $env:RUNNER_TEMP "trufflehog_pkg"
            if (Test-Path $tmp) { Remove-Item $tmp -Recurse -Force }
            New-Item -Path $tmp -ItemType Directory | Out-Null
            $pkg = Join-Path $tmp $asset.name
            Invoke-WebRequest -Uri $asset.browser_download_url -OutFile $pkg
            $outDir = Join-Path $tmp "out"
            New-Item -Path $outDir -ItemType Directory | Out-Null
            if ($asset.name -like "*.zip") {
              Expand-Archive -Path $pkg -DestinationPath $outDir -Force
            } else {
              tar -xzf $pkg -C $outDir
            }
            $exe = Get-ChildItem -Path $outDir -Recurse -File | Where-Object { $_.Name -ieq "trufflehog.exe" } | Select-Object -First 1
            if ($exe) {
              Add-Content -Path $env:GITHUB_PATH -Value $exe.DirectoryName
              Write-Host "Installed TruffleHog at $($exe.FullName)"
            } else {
              Write-Host "TruffleHog executable not found after extraction; continuing without install."
            }
          } catch {
            Write-Host "TruffleHog install failed: $($_.Exception.Message)"
            Write-Host "Continuing release workflow with SKIPPED trufflehog status if binary unavailable."
          }

      - name: Build with PyInstaller
        working-directory: source
        shell: pwsh
        run: |
          python -m PyInstaller --noconfirm --distpath ../dist --workpath ../build sins_editor.spec

      - name: Package fallback zip and metadata
        shell: pwsh
        run: |
          if (-not (Test-Path "dist/sins_editor.exe")) {
            throw "dist/sins_editor.exe not found after build."
          }
          if (-not (Test-Path "dist/sins_editor-onedir")) {
            throw "dist/sins_editor-onedir not found after build."
          }
          if (Test-Path "dist/sins_editor-onedir.zip") {
            Remove-Item "dist/sins_editor-onedir.zip" -Force
          }
          Compress-Archive -Path "dist/sins_editor-onedir" -DestinationPath "dist/sins_editor-onedir.zip" -CompressionLevel Optimal -Force

          $match = Select-String -Path "source/core/constants.py" -Pattern 'APP_VERSION\s*=\s*"([^"]+)"' | Select-Object -First 1
          $version = ""
          if ($match -and $match.Matches.Count -gt 0) {
            $version = $match.Matches[0].Groups[1].Value
          }
          if ([string]::IsNullOrWhiteSpace($version)) {
            throw "Failed to parse APP_VERSION from source/core/constants.py."
          }
          Set-Content -Path "dist/version.txt" -Value $version -Encoding ASCII

          $exeHash = (Get-FileHash -Algorithm SHA256 -Path "dist/sins_editor.exe").Hash.ToLowerInvariant()
          Set-Content -Path "dist/sins_editor.exe.sha256" -Value "$exeHash *sins_editor.exe" -Encoding ASCII

          $zipHash = (Get-FileHash -Algorithm SHA256 -Path "dist/sins_editor-onedir.zip").Hash.ToLowerInvariant()

      - name: Generate full security report
        shell: pwsh
        env:
          RELEASE_TAG: ${{ steps.vars.outputs.tag }}
          VT_API_KEY: ${{ secrets.VT_API_KEY }}
          HACKHUB_VT_STRICT: ${{ vars.HACKHUB_VT_STRICT }}
          HACKHUB_VT_FAIL_ON_SUSPICIOUS: ${{ vars.HACKHUB_VT_FAIL_ON_SUSPICIOUS }}
        run: |
          python - <<'PY'
          import datetime as dt
          import hashlib
          import json
          import os
          import shutil
          import subprocess
          import urllib.error
          import urllib.request
          from pathlib import Path

          dist = Path("dist")
          src_root = Path("source")
          exe_path = dist / "sins_editor.exe"
          zip_path = dist / "sins_editor-onedir.zip"
          ver_path = dist / "version.txt"
          report_path = dist / "security-report.txt"

          def run_cmd(args):
              try:
                  p = subprocess.run(args, capture_output=True, text=True, check=False)
                  return p.returncode, (p.stdout or ""), (p.stderr or "")
              except Exception as exc:
                  return 999, "", str(exc)

          def file_sha(path: Path):
              h = hashlib.sha256()
              with path.open("rb") as f:
                  for chunk in iter(lambda: f.read(1024 * 1024), b""):
                      h.update(chunk)
              return h.hexdigest()

          app_version = ver_path.read_text(encoding="ascii", errors="replace").strip()
          release_tag = (os.getenv("RELEASE_TAG") or "").strip()
          built_utc = dt.datetime.utcnow().strftime("%Y-%m-%dT%H:%M:%SZ")

          git_branch = "main"
          rc, out, _ = run_cmd(["git", "rev-parse", "--abbrev-ref", "HEAD"])
          if rc == 0 and out.strip():
              git_branch = out.strip()
          rc, out, _ = run_cmd(["git", "rev-parse", "--short", "HEAD"])
          git_short = out.strip() if rc == 0 else "unknown"
          rc, out, _ = run_cmd(["git", "rev-parse", "HEAD"])
          git_full = out.strip() if rc == 0 else "unknown"
          rc, out, _ = run_cmd(["git", "describe", "--tags", "--exact-match"])
          git_tag_exact = out.strip() if rc == 0 and out.strip() else "none"

          exe_sha = file_sha(exe_path)
          zip_sha = file_sha(zip_path)
          ver_sha = file_sha(ver_path)
          checksum_path = dist / "sins_editor.exe.sha256"
          expected_sha = ""
          if checksum_path.exists():
              expected_sha = checksum_path.read_text(encoding="ascii", errors="replace").strip().split(" ")[0].lower()
          sha_match = str(exe_sha == expected_sha).lower() if expected_sha else "false"

          # Semgrep
          semgrep_findings = 0
          semgrep_status = "SKIPPED"
          semgrep_strict = "false"
          rc, out, err = run_cmd(
              [
                  os.sys.executable,
                  "-m",
                  "semgrep",
                  "--config",
                  "p/python",
                  "--json",
                  str(src_root / "sins_editor.py"),
                  str(src_root / "core"),
                  str(src_root / "services"),
              ]
          )
          try:
              payload = json.loads(out or "{}")
              semgrep_findings = len(payload.get("results", []))
              semgrep_status = "PASS" if semgrep_findings == 0 else "FAIL"
          except Exception:
              semgrep_status = "SKIPPED"

          # TruffleHog
          trufflehog_status = "SKIPPED"
          trufflehog_findings = 0
          trufflehog_verified = 0
          trufflehog_unverified = 0
          trufflehog_unknown = 0
          trufflehog_strict = "false"
          trufflehog_results = "verified,unknown"
          trufflehog_exclude = "n/a (public workflow)"
          trufflehog_bin = shutil.which("trufflehog")
          if trufflehog_bin:
              rc, out, err = run_cmd(
                  [
                      trufflehog_bin,
                      "filesystem",
                      str(src_root),
                      "--json",
                      "--no-update",
                      "--results=verified,unknown",
                      "--force-skip-binaries",
                      "--force-skip-archives",
                  ]
              )
              findings = []
              for raw in (out or "").splitlines():
                  raw = raw.strip()
                  if not raw:
                      continue
                  try:
                      obj = json.loads(raw)
                  except Exception:
                      continue
                  # Finding objects include detector/source metadata; ignore pure info rows.
                  if isinstance(obj, dict) and (
                      "DetectorName" in obj or "Raw" in obj or "SourceMetadata" in obj
                  ):
                      findings.append(obj)
              trufflehog_findings = len(findings)
              for obj in findings:
                  v = obj.get("Verified")
                  if v is True:
                      trufflehog_verified += 1
                  elif v is False:
                      trufflehog_unverified += 1
                  else:
                      trufflehog_unknown += 1
              trufflehog_status = "PASS" if trufflehog_findings == 0 else "FAIL"

          # Defender local scan (best-effort)
          defender_status = "SKIPPED"
          defender_source = "local_scan"
          defender_threat = "false"
          defender_threat_count = 0
          defender_exit = "n/a"
          defender_reason = "not_run"
          defender_engine = "unknown"
          defender_signature = "unknown"
          defender_output_excerpt = ""
          mpcmd = shutil.which("MpCmdRun.exe")
          if mpcmd:
              rc_ver, out_ver, err_ver = run_cmd([mpcmd, "-GetEngineVersion"])
              ver_text = (out_ver or "") + "\n" + (err_ver or "")
              for raw_line in ver_text.splitlines():
                  line = raw_line.strip()
                  lower = line.lower()
                  if "engine version" in lower and ":" in line:
                      defender_engine = line.split(":", 1)[1].strip()
                  if "antispyware signature version" in lower and ":" in line:
                      defender_signature = line.split(":", 1)[1].strip()
              rc, out, err = run_cmd([mpcmd, "-Scan", "-ScanType", "3", "-File", str(exe_path)])
              defender_exit = str(rc)
              scan_text = ((out or "") + "\n" + (err or "")).strip()
              if scan_text:
                  defender_output_excerpt = " | ".join(scan_text.splitlines()[:3]).strip()
              if rc == 0:
                  defender_status = "PASS"
                  defender_reason = "no_threats_detected"
              elif rc == 2:
                  defender_status = "FAIL"
                  defender_threat = "true"
                  defender_threat_count = 1
                  defender_reason = "threat_detected"
              else:
                  defender_status = "SKIPPED"
                  defender_reason = f"unexpected_exit_{rc}"
          else:
              mpcmd = "MpCmdRun.exe"
              defender_reason = "mpcmd_not_found_on_runner"

          # VirusTotal
          vt_status = "SKIPPED"
          vt_source = "no_api_key"
          vt_mal = 0
          vt_susp = 0
          vt_harm = 0
          vt_und = 0
          vt_timeout = "false"
          vt_link = f"https://www.virustotal.com/gui/file/{exe_sha}/detection"
          vt_api_key = (os.getenv("VT_API_KEY") or "").strip()
          vt_strict = (os.getenv("HACKHUB_VT_STRICT") or "").strip().lower() in {"1", "true", "yes", "on"}
          vt_fail_on_susp = (os.getenv("HACKHUB_VT_FAIL_ON_SUSPICIOUS") or "").strip().lower() in {"1", "true", "yes", "on"}
          if vt_api_key:
              req = urllib.request.Request(
                  f"https://www.virustotal.com/api/v3/files/{exe_sha}",
                  headers={
                      "x-apikey": vt_api_key,
                      "Accept": "application/json",
                      "User-Agent": "HackHub-Release-Workflow/1.0",
                  },
                  method="GET",
              )
              try:
                  with urllib.request.urlopen(req, timeout=30) as resp:
                      payload = json.loads(resp.read().decode("utf-8", "replace") or "{}")
                  stats = (((payload.get("data") or {}).get("attributes") or {}).get("last_analysis_stats") or {})
                  vt_mal = int(stats.get("malicious", 0) or 0)
                  vt_susp = int(stats.get("suspicious", 0) or 0)
                  vt_harm = int(stats.get("harmless", 0) or 0)
                  vt_und = int(stats.get("undetected", 0) or 0)
                  vt_source = "hash_lookup"
                  if vt_mal > 0 or (vt_fail_on_susp and vt_susp > 0):
                      vt_status = "FAIL"
                  else:
                      vt_status = "PASS"
              except urllib.error.HTTPError as exc:
                  if exc.code == 404:
                      vt_source = "hash_miss"
                      vt_status = "FAIL" if vt_strict else "SKIPPED"
                  else:
                      vt_source = f"http_{exc.code}"
                      vt_status = "FAIL" if vt_strict else "SKIPPED"
              except Exception:
                  vt_source = "request_error"
                  vt_status = "FAIL" if vt_strict else "SKIPPED"
          elif vt_strict:
              vt_status = "FAIL"

          # Bandit
          bandit_status = "SKIPPED"
          bandit_findings = 0
          rc, out, err = run_cmd(
              [
                  os.sys.executable,
                  "-m",
                  "bandit",
                  "-q",
                  "-r",
                  str(src_root / "sins_editor.py"),
                  str(src_root / "core"),
                  str(src_root / "services"),
                  "-f",
                  "json",
              ]
          )
          try:
              b = json.loads(out or "{}")
              bandit_findings = len(b.get("results", []))
              bandit_status = "PASS" if bandit_findings == 0 else "FAIL"
          except Exception:
              bandit_status = "SKIPPED"

          # Safety
          safety_status = "SKIPPED"
          safety_mode = "check"
          safety_packages = 0
          safety_vuln = 0
          safety_ignored = 0
          rc, out, err = run_cmd([os.sys.executable, "-m", "safety", "check", "--output", "json"])
          try:
              s = json.loads(out or "{}")
              vulns = s.get("vulnerabilities") if isinstance(s, dict) else []
              if vulns is None:
                  vulns = []
              safety_vuln = len(vulns)
              safety_packages = len(s.get("scanned_packages", {}) or {})
              safety_status = "PASS" if safety_vuln == 0 else "FAIL"
          except Exception:
              safety_status = "SKIPPED"

          lines = [
              "HackHub Release Security Report",
              "report_format: v2",
              "",
              f"generated_utc: {built_utc}",
              f"app_version: {app_version}",
              "",
              "[ Build Source ]",
              f"git_branch: {git_branch}",
              f"git_commit_short: {git_short}",
              f"git_commit_full: {git_full}",
              f"git_tag_exact: {git_tag_exact}",
              "",
              "[ Primary Update Asset Integrity ]",
              "asset_name: sins_editor.exe",
              f"asset_size_bytes: {exe_path.stat().st_size}",
              f"asset_sha256_actual: {exe_sha}",
              f"asset_sha256_expected: {expected_sha or 'unknown'}",
              f"asset_sha256_match: {sha_match}",
              "checksum_file: sins_editor.exe.sha256",
              "authenticode_status: NotSigned",
              "authenticode_signer_subject: None",
              "authenticode_signer_thumbprint: None",
              "",
              "[ Security Gates ]",
              f"semgrep_status: {semgrep_status}",
              f"semgrep_findings: {semgrep_findings}",
              f"semgrep_strict_mode: {semgrep_strict}",
              "semgrep_ruleset: p/python",
              f"trufflehog_status: {trufflehog_status}",
              f"trufflehog_findings: {trufflehog_findings}",
              f"trufflehog_verified: {trufflehog_verified}",
              f"trufflehog_unverified: {trufflehog_unverified}",
              f"trufflehog_unknown: {trufflehog_unknown}",
              f"trufflehog_strict_mode: {trufflehog_strict}",
              f"trufflehog_results: {trufflehog_results}",
              f"trufflehog_exclude_paths: {trufflehog_exclude}",
              f"defender_status: {defender_status}",
              f"defender_source: {defender_source}",
              f"defender_threat_detected: {defender_threat}",
              f"defender_threat_count: {defender_threat_count}",
              f"defender_exit_code: {defender_exit}",
              f"defender_mpcmd: {mpcmd}",
              f"defender_reason: {defender_reason}",
              f"defender_engine_version: {defender_engine}",
              f"defender_signature_version: {defender_signature}",
              f"defender_output_excerpt: {defender_output_excerpt or 'n/a'}",
              f"virustotal_status: {vt_status}",
              f"virustotal_source: {vt_source}",
              f"virustotal_sha256: {exe_sha}",
              f"virustotal_malicious: {vt_mal}",
              f"virustotal_suspicious: {vt_susp}",
              f"virustotal_harmless: {vt_harm}",
              f"virustotal_undetected: {vt_und}",
              f"virustotal_timeout: {vt_timeout}",
              f"virustotal_permalink: {vt_link}",
              f"bandit_status: {bandit_status}",
              f"bandit_findings_above_gate_threshold: {bandit_findings}",
              "bandit_targets: sins_editor.py, core, services",
              "bandit_skipped_test_ids: B310",
              f"safety_status: {safety_status}",
              f"safety_mode: {safety_mode}",
              f"safety_packages_found: {safety_packages}",
              f"safety_vulnerabilities_found: {safety_vuln}",
              f"safety_vulnerabilities_ignored: {safety_ignored}",
              "",
              "[ Shipped Asset SHA256 ]",
              "note: security-report.txt is excluded from this list to avoid self-reference.",
              f"asset: dist\\sins_editor.exe",
              "asset_name: sins_editor.exe",
              f"asset_size_bytes: {exe_path.stat().st_size}",
              f"asset_sha256: {exe_sha}",
              "",
              f"asset: dist\\version.txt",
              "asset_name: version.txt",
              f"asset_size_bytes: {ver_path.stat().st_size}",
              f"asset_sha256: {ver_sha}",
              "",
              f"asset: dist\\sins_editor.exe.sha256",
              "asset_name: sins_editor.exe.sha256",
              f"asset_size_bytes: {checksum_path.stat().st_size if checksum_path.exists() else 0}",
              f"asset_sha256: {file_sha(checksum_path) if checksum_path.exists() else 'unknown'}",
              "",
              f"asset: dist\\sins_editor-onedir.zip",
              "asset_name: sins_editor-onedir.zip",
              f"asset_size_bytes: {zip_path.stat().st_size}",
              f"asset_sha256: {zip_sha}",
          ]

          report_path.write_text("\n".join(lines) + "\n", encoding="utf-8")
          print("Generated dist/security-report.txt in v2 full format.")
          PY

      - name: Install Cosign
        uses: sigstore/cosign-installer@v3

      - name: Sigstore keyless sign artifacts
        shell: pwsh
        run: |
          $artifacts = @(
            "dist/sins_editor.exe",
            "dist/sins_editor-onedir.zip",
            "dist/version.txt",
            "dist/sins_editor.exe.sha256",
            "dist/security-report.txt"
          )
          foreach ($path in $artifacts) {
            if (-not (Test-Path $path)) {
              throw "Missing artifact for signing: $path"
            }
            cosign sign-blob --yes `
              --output-signature "$path.sig" `
              --output-certificate "$path.cert" `
              "$path"
          }

      - name: Bundle Sigstore proofs
        shell: pwsh
        run: |
          $zipPath = "dist/sigstore-proofs.zip"
          if (Test-Path $zipPath) {
            Remove-Item $zipPath -Force
          }
          $proofFiles = Get-ChildItem "dist" -File | Where-Object { $_.Name -match "\.(sig|cert)$" } | Sort-Object Name
          if (-not $proofFiles -or $proofFiles.Count -eq 0) {
            throw "No Sigstore proof files found to bundle."
          }
          Compress-Archive -Path ($proofFiles | ForEach-Object { $_.FullName }) -DestinationPath $zipPath -CompressionLevel Optimal -Force

      - name: Build release page sections
        shell: pwsh
        run: |
          $version = "${{ steps.vars.outputs.version }}"
          $changelogPath = "source/assets/Readme.txt"
          $changelogLines = @()
          if (Test-Path $changelogPath) {
            $lines = Get-Content -Path $changelogPath
            $escapedVersion = [Regex]::Escape($version)
            $versionPattern = "^\[\s*Version\s+$escapedVersion\s*\]$"
            $startIndex = -1
            for ($i = 0; $i -lt $lines.Count; $i++) {
              if ($lines[$i].Trim() -match $versionPattern) {
                $startIndex = $i + 1
                break
              }
            }
            if ($startIndex -ge 0) {
              for ($j = $startIndex; $j -lt $lines.Count; $j++) {
                $current = $lines[$j].Trim()
                if ($current -match "^\[.*\]$") {
                  break
                }
                if ($current -match "^- ") {
                  $changelogLines += $current
                }
              }
            }
          }
          if (-not $changelogLines -or $changelogLines.Count -eq 0) {
            $changelogLines = @("- No changelog notes provided.")
          }

          $body = @(
            '## Changelog'
          ) + $changelogLines + @(
            '',
            '## Download',
            '- `sins_editor.exe` (main app)',
            '- `sins_editor-onedir.zip` (portable fallback)',
            '',
            '## Verify',
            '- `sins_editor.exe.sha256`',
            '- `sigstore-proofs.zip`',
            '',
            '## Release Metadata',
            '- `version.txt`',
            '- `security-report.txt`',
            '',
            '## Changelog Information',
            'Auto-generated changelog notes are appended below.'
          )
          Set-Content -Path "dist/release-body.md" -Value ($body -join "`r`n") -Encoding UTF8

      - name: Sync public README changelog row
        shell: pwsh
        run: |
          python - <<'PY'
          from pathlib import Path
          import os
          import re
          import sys

          version = os.environ.get("APP_VERSION", "").strip()
          if not version:
              print("APP_VERSION env is required.", file=sys.stderr)
              sys.exit(1)

          readme_txt = Path("source/assets/Readme.txt")
          public_readme = Path("README.md")
          if not readme_txt.exists() or not public_readme.exists():
              print("Required files missing for README changelog sync.", file=sys.stderr)
              sys.exit(1)

          src_lines = readme_txt.read_text(encoding="utf-8", errors="replace").splitlines()
          target_header = f"[ Version {version} ]".lower()
          start = -1
          for i, line in enumerate(src_lines):
              if line.strip().lower() == target_header:
                  start = i + 1
                  break

          bullets = []
          if start >= 0:
              for line in src_lines[start:]:
                  t = line.strip()
                  if re.match(r"^\[.*\]$", t):
                      break
                  if t.startswith("- "):
                      bullets.append(t)

          if not bullets:
              bullets = ["- No changelog notes provided."]

          row = f"| **[ Version {version} ]**<br>" + "<br>".join(bullets) + " |"

          readme_lines = public_readme.read_text(encoding="utf-8", errors="replace").splitlines()
          change_logs_idx = -1
          for i, line in enumerate(readme_lines):
              if 'alt="CHANGE LOGS"' in line:
                  change_logs_idx = i
                  break

          if change_logs_idx < 0:
              print("CHANGE LOGS section not found in README.md", file=sys.stderr)
              sys.exit(1)

          replace_idx = -1
          for i in range(change_logs_idx + 1, min(change_logs_idx + 12, len(readme_lines))):
              if readme_lines[i].startswith("| **[ Version "):
                  replace_idx = i
                  break

          if replace_idx < 0:
              print("Version row not found near CHANGE LOGS section in README.md", file=sys.stderr)
              sys.exit(1)

          readme_lines[replace_idx] = row
          public_readme.write_text("\n".join(readme_lines) + "\n", encoding="utf-8")
          print(f"Synced README.md CHANGE LOGS row to Version {version}")
          PY
        env:
          APP_VERSION: ${{ steps.vars.outputs.version }}

      - name: Commit README changelog sync
        shell: pwsh
        run: |
          if ((git status --porcelain README.md).Length -eq 0) {
            Write-Host "README.md changelog already up to date."
            exit 0
          }
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add README.md
          git commit -m "Sync public README changelog for v${{ steps.vars.outputs.version }}"
          git push origin HEAD:main

      - name: Publish GitHub release assets
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.vars.outputs.tag }}
          name: Sins Editor ${{ steps.vars.outputs.version }} x64
          body_path: dist/release-body.md
          append_body: false
          generate_release_notes: false
          files: |
            dist/sins_editor.exe
            dist/sins_editor-onedir.zip
            dist/sins_editor.exe.sha256
            dist/version.txt
            dist/security-report.txt
            dist/sigstore-proofs.zip
