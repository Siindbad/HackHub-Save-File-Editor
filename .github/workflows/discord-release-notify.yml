name: Discord Release Notify

on:
  release:
    types: [published, prereleased]
  workflow_run:
    workflows: ["Release Build and Sigstore Sign"]
    types: [completed]
  workflow_dispatch:
    inputs:
      tag:
        description: "Release tag override (optional)"
        required: false
        type: string
      title:
        description: "Release title override (optional)"
        required: false
        type: string
      url:
        description: "Release URL override (optional)"
        required: false
        type: string
      notes:
        description: "Release notes override (optional)"
        required: false
        type: string
      style:
        description: "Theme style (SIINDBAD or KAMUE)"
        required: false
        default: "SIINDBAD"
        type: choice
        options:
          - SIINDBAD
          - KAMUE
      prerelease:
        description: "Mark manual dispatch as prerelease"
        required: false
        default: false
        type: boolean

permissions:
  contents: read

jobs:
  notify:
    runs-on: ubuntu-latest
    steps:
      - name: Send Discord release message
        env:
          DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_RELEASE_WEBHOOK }}
          EVENT_NAME: ${{ github.event_name }}
          RELEASE_TAG: ${{ github.event.release.tag_name }}
          RELEASE_NAME: ${{ github.event.release.name }}
          RELEASE_URL: ${{ github.event.release.html_url }}
          RELEASE_BODY: ${{ github.event.release.body }}
          RELEASE_IS_PRERELEASE: ${{ github.event.release.prerelease }}
          WORKFLOW_CONCLUSION: ${{ github.event.workflow_run.conclusion }}
          WORKFLOW_NAME: ${{ github.event.workflow_run.name }}
          WORKFLOW_URL: ${{ github.event.workflow_run.html_url }}
          WORKFLOW_BRANCH: ${{ github.event.workflow_run.head_branch }}
          WORKFLOW_ID: ${{ github.event.workflow_run.id }}
          MANUAL_TAG: ${{ inputs.tag }}
          MANUAL_TITLE: ${{ inputs.title }}
          MANUAL_URL: ${{ inputs.url }}
          MANUAL_NOTES: ${{ inputs.notes }}
          MANUAL_STYLE: ${{ inputs.style }}
          MANUAL_PRERELEASE: ${{ inputs.prerelease }}
          REPO_NAME: ${{ github.repository }}
          DEFAULT_STYLE: ${{ vars.DISCORD_RELEASE_STYLE }}
          DISCORD_USERNAME: ${{ vars.DISCORD_RELEASE_USERNAME }}
          DISCORD_AVATAR_URL: ${{ vars.DISCORD_RELEASE_AVATAR_URL }}
          DISCORD_MENTION: ${{ vars.DISCORD_RELEASE_MENTION }}
          DISCORD_COLOR: ${{ vars.DISCORD_RELEASE_COLOR }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        shell: bash
        run: |
          python - <<'PY'
          import json
          import os
          import sys
          import time
          import urllib.error
          import urllib.request

          webhook = (os.getenv("DISCORD_WEBHOOK_URL") or "").strip()
          event_name = (os.getenv("EVENT_NAME") or "").strip()
          is_release_event = event_name == "release"
          is_workflow_event = event_name == "workflow_run"
          if not webhook:
              if is_release_event or is_workflow_event:
                  print("DISCORD_RELEASE_WEBHOOK is not set. Failing release notify.", file=sys.stderr)
                  sys.exit(1)
              print("DISCORD_RELEASE_WEBHOOK is not set. Skipping Discord notify.")
              sys.exit(0)
          workflow_conclusion = (os.getenv("WORKFLOW_CONCLUSION") or "").strip().lower()

          def _pick(*values):
              for value in values:
                  text = (value or "").strip()
                  if text:
                      return text
              return ""

          def _sanitize_changelog(raw_text):
              text = (raw_text or "").strip()
              if not text:
                  return ""
              filtered = []
              skip_block = False
              skip_heads = {
                  "## download",
                  "## verify",
                  "## release metadata",
                  "## changelog information",
              }
              for line in text.splitlines():
                  stripped = line.strip()
                  lowered = stripped.lower()
                  if lowered in skip_heads:
                      skip_block = True
                      continue
                  if lowered.startswith("## ") and lowered not in skip_heads:
                      skip_block = False
                  if skip_block:
                      continue
                  if lowered.startswith("auto-generated changelog notes are appended below."):
                      continue
                  if lowered.startswith("full changelog:"):
                      continue
                  filtered.append(line)
              cleaned = "\n".join(filtered).strip()
              if not cleaned:
                  return ""
              while "\n\n\n" in cleaned:
                  cleaned = cleaned.replace("\n\n\n", "\n\n")
              return cleaned

          def _compact_changelog(raw_text, max_items=12):
              text = (raw_text or "").strip()
              if not text:
                  return ""
              bullets = []
              for line in text.splitlines():
                  stripped = line.strip()
                  if stripped.startswith("- "):
                      item = " ".join(stripped[2:].split())
                      if item:
                          bullets.append(item.rstrip("."))
              if not bullets:
                  compact = " ".join(text.split())
                  return f"- {compact}" if compact else ""
              compact_items = []
              for item in bullets[:max_items]:
                  compact_items.append(f"- {item}.")
              return "\n".join(compact_items)

          def _extract_version_changelog_from_readme(readme_text, version_text):
              text = (readme_text or "")
              version = (version_text or "").strip()
              if not text or not version:
                  return ""
              lines = text.splitlines()
              target = f"[ Version {version} ]".lower()
              start = -1
              for idx, line in enumerate(lines):
                  if line.strip().lower() == target:
                      start = idx + 1
                      break
              if start < 0:
                  return ""
              bullets = []
              for line in lines[start:]:
                  trimmed = line.strip()
                  if trimmed.startswith("[") and trimmed.endswith("]"):
                      break
                  if trimmed.startswith("- "):
                      bullets.append(trimmed)
              return "\n".join(bullets).strip()

          def _load_source_readme_changelog(repo_name, tag_name):
              tag = (tag_name or "").strip()
              if not repo_name or not tag:
                  return ""
              version = tag[1:] if tag.lower().startswith("v") else tag
              # Pull from source-of-truth changelog file in repo main.
              url = f"https://raw.githubusercontent.com/{repo_name}/main/source/assets/Readme.txt"
              req = urllib.request.Request(
                  url,
                  headers={
                      "Accept": "text/plain",
                      "User-Agent": "HackHub-Release-Notifier/1.0 (+https://github.com/Siindbad/HackHub-Save-File-Editor)",
                  },
                  method="GET",
              )
              try:
                  with urllib.request.urlopen(req, timeout=30) as resp:
                      content = resp.read().decode("utf-8", "replace")
                  return _extract_version_changelog_from_readme(content, version)
              except Exception as exc:
                  print(f"Failed to load source Readme changelog fallback: {exc}", file=sys.stderr)
                  return ""

          def _load_latest_release(repo_name):
              token = (os.getenv("GH_TOKEN") or "").strip()
              if not repo_name:
                  return {}
              req = urllib.request.Request(
                  f"https://api.github.com/repos/{repo_name}/releases/latest",
                  headers={
                      "Accept": "application/vnd.github+json",
                      "User-Agent": "HackHub-Release-Notifier/1.0 (+https://github.com/Siindbad/HackHub-Save-File-Editor)",
                      **({"Authorization": f"Bearer {token}"} if token else {}),
                  },
                  method="GET",
              )
              try:
                  with urllib.request.urlopen(req, timeout=30) as resp:
                      return json.loads(resp.read().decode("utf-8", "replace") or "{}")
              except Exception as exc:
                  print(f"Failed to load latest release metadata: {exc}", file=sys.stderr)
                  return {}

          def _load_release_by_tag(repo_name, tag_name):
              token = (os.getenv("GH_TOKEN") or "").strip()
              tag = (tag_name or "").strip()
              if not repo_name or not tag:
                  return {}
              req = urllib.request.Request(
                  f"https://api.github.com/repos/{repo_name}/releases/tags/{tag}",
                  headers={
                      "Accept": "application/vnd.github+json",
                      "User-Agent": "HackHub-Release-Notifier/1.0 (+https://github.com/Siindbad/HackHub-Save-File-Editor)",
                      **({"Authorization": f"Bearer {token}"} if token else {}),
                  },
                  method="GET",
              )
              try:
                  with urllib.request.urlopen(req, timeout=30) as resp:
                      return json.loads(resp.read().decode("utf-8", "replace") or "{}")
              except Exception as exc:
                  print(f"Failed to load release metadata by tag '{tag}': {exc}", file=sys.stderr)
                  return {}

          repo = (os.getenv("REPO_NAME") or "").strip()
          workflow_name = (os.getenv("WORKFLOW_NAME") or "").strip() or "Release Build and Sigstore Sign"
          workflow_url = (os.getenv("WORKFLOW_URL") or "").strip()
          workflow_branch = (os.getenv("WORKFLOW_BRANCH") or "").strip() or "main"
          workflow_id = (os.getenv("WORKFLOW_ID") or "").strip()
          latest_release = {}
          manual_tag = (os.getenv("MANUAL_TAG") or "").strip()
          if event_name == "workflow_run":
              if workflow_conclusion == "success":
                  latest_release = _load_latest_release(repo)
          elif event_name == "workflow_dispatch":
              latest_release = _load_release_by_tag(repo, manual_tag) if manual_tag else _load_latest_release(repo)

          tag = _pick(manual_tag, os.getenv("RELEASE_TAG"), latest_release.get("tag_name"))
          title = _pick(
              os.getenv("MANUAL_TITLE"),
              os.getenv("RELEASE_NAME"),
              latest_release.get("name"),
              f"Release {tag}" if tag else "",
          )
          url = _pick(os.getenv("MANUAL_URL"), os.getenv("RELEASE_URL"), latest_release.get("html_url"))
          notes = _pick(os.getenv("MANUAL_NOTES"), os.getenv("RELEASE_BODY"), latest_release.get("body"))

          manual_pre = (os.getenv("MANUAL_PRERELEASE") or "").strip().lower() in {"1", "true", "yes", "on"}
          event_pre = _pick(os.getenv("RELEASE_IS_PRERELEASE"), str(latest_release.get("prerelease", ""))).lower() in {"1", "true", "yes", "on"}
          is_prerelease = manual_pre if event_name == "workflow_dispatch" else event_pre
          style = _pick(os.getenv("MANUAL_STYLE"), os.getenv("DEFAULT_STYLE"), "SIINDBAD").upper()
          if style not in {"SIINDBAD", "KAMUE"}:
              style = "SIINDBAD"

          mention = (os.getenv("DISCORD_MENTION") or "").strip()
          content = mention if mention else ""

          color_text = (os.getenv("DISCORD_COLOR") or "").strip()
          try:
              if color_text:
                  color = int(color_text)
              elif style == "KAMUE":
                  color = 12336895
              else:
                  # Darker cyan accent for SIINDBAD release embeds.
                  color = 16753920 if is_prerelease else 757408
          except Exception:
              color = 5814783

          releases_url = f"https://github.com/{repo}/releases" if repo else ""
          is_release_failure = event_name == "workflow_run" and workflow_conclusion != "success"
          if is_release_failure:
              run_link = workflow_url or (f"https://github.com/{repo}/actions/runs/{workflow_id}" if (repo and workflow_id) else "")
              status = (workflow_conclusion or "failed").upper()
              embed_title = f"SINS SAVE EDITOR RELEASE {status}"
              detail_lines = [
                  f"Workflow: `{workflow_name}`",
                  f"Branch: `{workflow_branch}`",
                  f"Conclusion: `{workflow_conclusion or 'unknown'}`",
              ]
              if run_link:
                  detail_lines.append(f"[Open Workflow Run]({run_link})")
              description = "Release pipeline failed.\n\n" + "\n".join(detail_lines)
          else:
              version_label = tag or title or "N/A"
              embed_title = f"SINS SAVE EDITOR {version_label}"
              notes_text = _sanitize_changelog(notes)
              if not notes_text:
                  notes_text = _load_source_readme_changelog(repo, tag)
              notes_text = _compact_changelog(notes_text)
              if len(notes_text) > 3850:
                  notes_text = notes_text[:3847] + "..."
              changelog_text = notes_text if notes_text else "- No changelog notes provided."
              download_line = f"[Download Latest Release]({url or releases_url})" if (url or releases_url) else ""
              if download_line:
                  description = f"New Release!\n\n{download_line}\n\n**Changelog**\n{changelog_text}"
              else:
                  description = f"New Release!\n\n**Changelog**\n{changelog_text}"

          embed_color = color
          if is_release_failure:
              embed_color = 15158332
          embed = {
              "title": embed_title,
              "description": description,
              "color": embed_color,
              "timestamp": time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime()),
          }
          if url and not is_release_failure:
              embed["url"] = url

          payload = {
              "content": content,
              "embeds": [embed],
              "allowed_mentions": {"parse": []},
          }

          username = (os.getenv("DISCORD_USERNAME") or "").strip()
          avatar = (os.getenv("DISCORD_AVATAR_URL") or "").strip()
          if username:
              payload["username"] = username
          if avatar:
              payload["avatar_url"] = avatar

          data = json.dumps(payload).encode("utf-8")
          for attempt in range(1, 6):
              req = urllib.request.Request(
                  webhook,
                  data=data,
                  headers={
                      "Content-Type": "application/json",
                      "Accept": "application/json",
                      "User-Agent": "HackHub-Release-Notifier/1.0 (+https://github.com/Siindbad/HackHub-Save-File-Editor)",
                  },
                  method="POST",
              )
              try:
                  with urllib.request.urlopen(req, timeout=30) as resp:
                      print(f"Discord notify sent (status={resp.status}).")
                      sys.exit(0)
              except urllib.error.HTTPError as exc:
                  raw = exc.read().decode("utf-8", "replace")
                  if exc.code == 429 and attempt < 5:
                      wait_s = 2.0
                      try:
                          body = json.loads(raw or "{}")
                          wait_s = float(body.get("retry_after", wait_s))
                          # Discord may return milliseconds in some contexts.
                          if wait_s > 30:
                              wait_s = wait_s / 1000.0
                      except Exception:
                          pass
                      wait_s = max(1.0, min(wait_s, 30.0))
                      print(f"Discord rate limit hit, retrying in {wait_s:.2f}s (attempt {attempt}/5).")
                      time.sleep(wait_s)
                      continue
                  print(f"Discord notify failed: HTTP {exc.code}: {raw}", file=sys.stderr)
                  sys.exit(1)
              except Exception as exc:
                  if attempt < 5:
                      time.sleep(2.0)
                      continue
                  print(f"Discord notify failed: {exc}", file=sys.stderr)
                  sys.exit(1)
          PY
